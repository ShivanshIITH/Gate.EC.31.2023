\documentclass[journal,12pt,onecolumn]{IEEEtran}
\usepackage{setspace}
\usepackage{gensymb}
\singlespacing
\usepackage[cmex10]{amsmath}
\usepackage{amsthm}
\usepackage{mathrsfs}
\usepackage{txfonts}
\usepackage{stfloats}
\usepackage{bm}
\usepackage{cite}
\usepackage{cases}
\usepackage{subfig}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{tikz}
\usepackage{circuitikz}
\usepackage{verbatim}
\usepackage[breaklinks=true]{hyperref}
\usepackage{tkz-euclide} % loads  TikZ and tkz-base
\usepackage{listings}
\usepackage{color}    
\usepackage{array}    
\usepackage{longtable}
\usepackage{calc}     

\usepackage{hhline}   
\usepackage{ifthen}   
\usepackage{lscape}     
\usepackage{chngcntr}
\usepackage{float}
\DeclareMathOperator*{\Res}{Res}
\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}

\renewcommand\thesectiondis{\arabic{section}}
\renewcommand\thesubsectiondis{\thesectiondis.\arabic{subsection}}
\renewcommand\thesubsubsectiondis{\thesubsectiondis.\arabic{subsubsection}}
\renewcommand\thetable{\arabic{table}}
% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
\def\inputGnumericTable{}                                 %%

\lstset{
%language=C,
frame=single, 
breaklines=true,
columns=fullflexible
}
%\lstset{
%language=tex,
%frame=single, 
%breaklines=true
%}

\begin{document}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{example}{Example}[section]
\newtheorem{definition}[problem]{Definition}
\newcommand{\BEQA}{\begin{eqnarray}}
\newcommand{\EEQA}{\end{eqnarray}}
\newcommand{\define}{\stackrel{\triangle}{=}}
\bibliographystyle{IEEEtran}
\providecommand{\mbf}{\mathbf}
\providecommand{\pr}[1]{\ensuremath{\Pr\left(#1\right)}}
\providecommand{\qfunc}[1]{\ensuremath{Q\left(#1\right)}}
\providecommand{\sbrak}[1]{\ensuremath{{}\left[#1\right]}}
\providecommand{\lsbrak}[1]{\ensuremath{{}\left[#1\right.}}
\providecommand{\rsbrak}[1]{\ensuremath{{}\left.#1\right]}}
\providecommand{\brak}[1]{\ensuremath{\left(#1\right)}}
\providecommand{\lbrak}[1]{\ensuremath{\left(#1\right.}}
\providecommand{\rbrak}[1]{\ensuremath{\left.#1\right)}}
\providecommand{\cbrak}[1]{\ensuremath{\left\{#1\right\}}}
\providecommand{\lcbrak}[1]{\ensuremath{\left\{#1\right.}}
\providecommand{\rcbrak}[1]{\ensuremath{\left.#1\right\}}}
\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newcommand{\sgn}{\mathop{\mathrm{sgn}}}
\providecommand{\abs}[1]{\left\vert#1\right\vert}
\providecommand{\res}[1]{\Res\displaylimits_{#1}} 
\providecommand{\norm}[1]{\left\lVert#1\right\rVert}
\providecommand{\mtx}[1]{\mathbf{#1}}
\providecommand{\mean}[1]{E\left[ #1 \right]}
\providecommand{\fourier}{\overset{\mathcal{F}}{ \rightleftharpoons}}
\providecommand{\system}[1]{\overset{\mathcal{#1}}{ \longleftrightarrow}}
\newcommand{\solution}{\noindent \textbf{Solution: }}
\newcommand{\cosec}{\,\text{cosec}\,}
\providecommand{\dec}[2]{\ensuremath{\overset{#1}{\underset{#2}{\gtrless}}}}
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}
\newcommand{\mydet}[1]{\ensuremath{\begin{vmatrix}#1\end{vmatrix}}}
\let\vec\mathbf
\def\putbox#1#2#3{\makebox[0in][l]{\makebox[#1][l]{}\raisebox{\baselineskip}[0in][0in]{\raisebox{#2}[0in][0in]{#3}}}}
     \def\rightbox#1{\makebox[0in][r]{#1}}
     \def\centbox#1{\makebox[0in]{#1}}
     \def\topbox#1{\raisebox{-\baselineskip}[0in][0in]{#1}}
     \def\midbox#1{\raisebox{-0.5\baselineskip}[0in][0in]{#1}}

\vspace{3cm}
\title{}
\author{EE22BTECH11049 - Shivansh Kirar}
\maketitle
\textbf{Question EC 31 2023}\\
The signal-to-noise ratio (SNR) of an ADC with a full-scale sinusoidal input is given to be 61.96 dB. The resolution of the ADC is \hfill{GATE EC 2023}

\textbf{Solution:}
\begin{table}[H]
\input{Table/a.tex}
\label{table:Gate.31.2023.0}
\end{table}
\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{Graph/a.png}
  \caption{Quantization of Sinusoidal Signal}
  \label{fig:Gate.31.2023.1}
\end{figure}
\enumerate
\item Signal Power: \\
The power of a continuous-time signal is defined as the average value of the square of the signal over a certain time interval. For a sinusoidal signal \(x(t) = A \sin(2\pi f t + \phi)\), the power (\(P_s\)) is calculated as:

\begin{equation}
P_s = \lim_{{T \to \infty}} \frac{1}{T} \int_{{-\frac{T}{2}}}^{{\frac{T}{2}}} |x(t)|^2 dt
\end{equation}

where \(\phi\) is the phase of the signal.

\begin{equation}
P_s = \lim_{{T \to \infty}} \frac{1}{T} \int_{{-\frac{T}{2}}}^{{\frac{T}{2}}} |A \sin(2\pi f t + \phi)|^2 dt
\end{equation}

\begin{equation}
P_s = \lim_{{T \to \infty}} \frac{1}{T} \int_{{-\frac{T}{2}}}^{{\frac{T}{2}}} A^2 \sin^2(2\pi f t + \phi) dt
\end{equation}

\begin{equation}
P_s = \lim_{{T \to \infty}} \frac{1}{T} \int_{{-\frac{T}{2}}}^{{\frac{T}{2}}} A^2 \cdot \frac{1 - \cos(4\pi f t + 2\phi)}{2} dt
\end{equation}

\begin{equation}
P_s = \frac{1}{2} \lim_{{T \to \infty}} \frac{1}{T} \int_{{-\frac{T}{2}}}^{{\frac{T}{2}}} A^2 dt - \frac{1}{2} \lim_{{T \to \infty}} \frac{1}{T} \int_{{-\frac{T}{2}}}^{{\frac{T}{2}}} A^2 \cos(4\pi f t + 2\phi) dt
\end{equation}

\begin{equation}
P_s = \frac{1}{2} \cdot A^2 - 0
\end{equation}

\begin{equation}
P_s = \frac{A^2}{2}
\end{equation}

Here, \(A = 1\), so:

\begin{equation}
P_s = \frac{1}{2}
\end{equation}
\item Noise Power:\\
Quantized to $2^n$ discrete levels, equivalent to $n$ bits, one quantization step $q$ has a size of
\begin{equation}
q = \frac{2}{2^{n}} = 2^{-(n-1)}
\end{equation}

We know,quantization error has a maximum value of plus or minus half the
step size, so 
\begin{equation}
\left| e \right| \leq \frac{q}{2} \text{ and therefore, } \left| e \right| \leq 2^{-n}
\end{equation}

For a large enough number of quantization steps, the probability density function of the quantization error tends toward being flat 1.
Pdf of error (e) of quantization is defined as 

\begin{equation}
P_e(X) = 
\begin{cases}
    \frac{1}{q}, & \text{if } -\frac{q}{2} < X < \frac{q}{2} \\
    0, & \text{otherwise}
\end{cases}
\end{equation}
\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{Graph/b.png}
  \caption{plot of pdf of Quantization Error}
  \label{fig:Gate.31.2023.2}
\end{figure}

So, we can calculate its mean power or variance as the 2nd moment of its distribution.\\
Since, the distribution of error is uniform hence E[e]=0.
\begin{equation}
E[e^{2}] = \int_{-\frac{q}{2}}^{\frac{q}{2}} p(e) e^{2} \, de 
= \frac{1}{q} \cdot \frac{1}{3} \left(\left(\frac{q}{2}\right)^{3} - \left(-\frac{q}{2}\right)^{3}\right)
=\frac{1}{3q} \cdot \frac{q^{3}}{4}
=\frac{q^{2}}{12}
\end{equation}

On putting \(q = 2^{-(n-1)}\), we have:
\begin{equation}
E[e^{2}] \approx \frac{2^{-2n}}{3}
\end{equation}
\begin{equation}
Pe \approx \frac{2^{-2n}}{3}
\end{equation}
Thus, an ideal ADC would have a signal-to-noise ratio
\begin{equation}
SNR = \frac{Ps}{Pe} = 1.5 \cdot 2^{2n}
\end{equation}

or, expressed in decibels,
\begin{equation}
SNR = 1.76 + 6.02n
\end{equation}

Plug in the values:
\begin{equation}
n = \frac{61.96 \text{ dB} - 1.76 \text{ dB}}{6.02 \text{ dB}} \approx 10 \text{ bits}
\end{equation}

So, the resolution of the ADC is approximately 10 bits.\\

\begin{enumerate}
\item Simulation and related steps
\end{enumerate}

\begin{verbatim}
import numpy as np

Given_SNR = 61.96 
# Signal parameters
amplitude = 1  # Amplitude of the sinusoidal signal
frequency = 10  # Frequency of the sinusoidal signal in Hz
sampling_frequency = 1000  # Sampling frequency in Hz
duration = 1  # Duration of the signal in seconds
num_samples = int(sampling_frequency * duration)
time = np.arange(0, duration, 1/sampling_frequency)

# Generating the full-scale sinusoidal input signal
input_signal = amplitude * np.sin(2 * np.pi * frequency * time)

# Calculate Signal Power (Ps) by averaging the square of the signal
signal_power = np.mean(input_signal**2)

# Initialize the simulated resolution as None
resolution_simulated = None

# Iteratating through different quantization bit values
for n in range(1, 20):
    # Calculate the number of quantization levels
    quantization_levels = 2**n
    
    # Calculate the quantization step size
    quantization_step = 2 * amplitude / quantization_levels
    
    # Quantize the input signal
    quantized_signal = np.round(input_signal / quantization_step) * quantization_step
    
    # Calculate the quantization error signal
    quantization_error_signal = input_signal - quantized_signal
    
    # Calculate Signal Power (Pe) of quantization error signal
    signal_power_quantization_error = np.mean(quantization_error_signal**2)
    
    # Calculate Signal Power in decibels (dB)
    SNR_simulated = 10 * np.log10(signal_power / signal_power_quantization_error)
    
    # Check if the simulated SNR is close to the given SNR with a tolerance of 1 dB
    if np.isclose(Given_SNR, SNR_simulated, atol=1):
        resolution_simulated = n
        break

print(f"Simulated Resolution: {resolution_simulated} bits")
\end{verbatim}

\end{document}
